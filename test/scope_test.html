<!DOCTYPE html>
<html>
<head>
  <base href=".">
  <title>BindingTree Unit Tests</title>

  <link rel="import" href="testutils.html">

  <link rel="import" href="../node_modules/spies/main_chai_expect.html">

  <script src="bin.js"></script>
</head>
<body>
  <script lang="es6">
  const RunContext = DIJS.RunContext;
  let expect = chai.expect;

  describe('Scope', () => {
    let scope;

    beforeEach(done => {
      scope = new DIJS.Scope();
      done();
    });

    function getLocalBinding(scope, key) {
      return t.getSymbolValue(scope, 'localBindings').get(key);
    }

    describe('#with', () => {
      it('should return a child scope with the given provider bound', () => {
        let provider = () => 1;
        let childScope = scope.with('key', provider);
        let binding = getLocalBinding(childScope, 'key');

        expect(t.getSymbolValue(binding, 'scope')).to.equal(childScope);
        expect(binding.provider).to.equal(provider);
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
      });
    });

    describe('#constant', () => {
      it('should return a child scope with the given constant bound', () => {
        let childScope = scope.constant('key', 1);

        expect(getLocalBinding(childScope, 'key').resolve(new RunContext())).to.equal(1);
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
      });
    });

    describe('#bind', () => {
      it('should bind the provider to the root scope', () => {
        let provider = () => 1;
        let descendant = scope.constant('a', 1).constant('b', 2);
        descendant.bind('c', provider);

        expect(getLocalBinding(scope, 'c').provider).to.equal(provider);
      });
      it('should return the current scope', () => {
        expect(scope.bind('a', () => 1)).to.equal(scope);
      });
      it('should throw error if a key is being bound twice', () => {
        scope.bind('a', () => 1);

        expect(() => { scope.bind('a', () => 2); }).to.throw('already bound');
      });
    });

    describe('#run', () => {
      it('should pass a require and optional function into the provider function', done => {
        scope.run((require, optional) => {
          expect(require).to.be.instanceof(Function);
          expect(optional).to.be.instanceof(Function);
          done();
        });
      });
    });

    describe('findBinding', () => {
      it('should favor provider bound locally', () => {
        let descendant = scope
            .constant('a', 1)
            .constant('a', 2);
        expect(descendant.findBinding('a').resolve(new RunContext())).to.equal(2);
      });
      it('should fallback to provider bound in the parent scope', () => {
        let descendant = scope
            .constant('a', 1)
            .constant('b', 2);
        expect(descendant.findBinding('a').resolve(new RunContext())).to.equal(1);
      });
      it('should return undefined if no provider is bound', () => {
        expect(scope.findBinding('a')).to.be.undefined;
      });
    });
  });
  </script>
</body>
