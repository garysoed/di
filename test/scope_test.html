<!DOCTYPE html>
<html>
<head>
  <base href=".">
  <title>BindingTree Unit Tests</title>

  <link rel="import" href="testutils.html">

  <link rel="import" href="../node_modules/spies/main_chai_expect.html">

  <script src="bin.js"></script>
</head>
<body>
  <script lang="es6">

  let expect = chai.expect;

  describe('Scope', () => {
    let scope;

    beforeEach(done => {
      scope = new DIJS.Scope();
      done();
    });

    function getLocalProvider(scope, key) {
      return t.getSymbolValue(scope, 'localBindings').get(key);
    }

    describe('#with', () => {
      it('should return a child scope with the given provider bound', () => {
        let provider = () => 1;
        let childScope = scope.with('key', provider);

        expect(getLocalProvider(childScope, 'key')).to.equal(provider);
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
      });
    });

    describe('#constant', () => {
      it('should return a child scope with the given constant bound', () => {
        let childScope = scope.constant('key', 1);

        expect(getLocalProvider(childScope, 'key')()).to.equal(1);
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
      });
    });

    describe('#bind', () => {
      it('should bind the provider to the root scope', () => {
        let provider = () => 1;
        let descendant = scope.constant('a', 1).constant('b', 2);
        descendant.bind('c', provider);

        expect(getLocalProvider(scope, 'c')).to.equal(provider);
      });
      it('should return the current scope', () => {
        expect(scope.bind('a', () => 1)).to.equal(scope);
      });
      it('should throw error if a key is being bound twice', () => {
        scope.bind('a', () => 1);

        expect(() => { scope.bind('a', () => 2); }).to.throw('already bound');
      });
    });

    describe('#run', () => {
      it('should pass a require and optional function into the provider function', done => {
        scope.run((require, optional) => {
          expect(require).to.be.instanceof(Function);
          expect(optional).to.be.instanceof(Function);
          done();
        });
      });
    });

    describe('optional', () => {
      it('should return the previously bound value', done => {
        scope
            .constant('a', 1)
            .run((require, optional) => {
              expect(optional('a')).to.equal(1);
              done();
            });
      });
      it('should return the previously returned value', done => {
        scope
            .constant('a', {})
            .run((require, optional) => {
              expect(optional('a')).to.equal(optional('a'));
              done();
            });
      });
      it('should return undefined for unbound value', done => {
        scope.run((require, optional) => {
              expect(optional('a')).to.be.undefined;
              done();
            });
      });
    });

    describe('require', () => {
      it('should return the previously bound value', done => {
        scope
            .constant('a', 1)
            .run(require => {
              expect(require('a')).to.equal(1);
              done();
            });
      });
      it('should return the previously returned value', done => {
        scope
            .constant('a', {})
            .run(require => {
              expect(require('a')).to.equal(require('a'));
              done();
            });
      });
      it('should throw error for unbound value', done => {
        scope.run(require => {
          expect(() => require('a')).to.throw('a');
          done();
        });
      });
    });

    describe('__findProvider__', () => {
      const __findProvider__ = t.getSymbol(DIJS.Scope.prototype, 'findProvider');

      it('should favor provider bound locally', () => {
        let descendant = scope
            .constant('a', 1)
            .constant('a', 2);
        expect(descendant[__findProvider__]('a')()).to.equal(2);
      });
      it('should fallback to provider bound in the parent scope', () => {
        let descendant = scope
            .constant('a', 1)
            .constant('b', 2);
        expect(descendant[__findProvider__]('a')()).to.equal(1);
      });
      it('should return undefined if no provider is bound', () => {
        expect(scope[__findProvider__]('a')).to.be.undefined;
      });
    });
  });
  </script>
</body>
